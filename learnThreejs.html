<!DOCTYPE html>
<html>
    <head> 
		<meta charset="utf-8">
		<title>learnThreejs</title>
		<style> body {margin: 0;}</style>
		<script src="js/three.js"></script>
	</head>	
	<body id="body">
		<script>


// controls handler
//initialize your variables here
const c = 5;
const m = 1;
var w = false;
var a = false;
var s = false;
var d = false;
var q = false;
var e = false;
var thrusters = 0;
var direction = new THREE.Vector3;//direction of camera
var hyperdrive = false;// when caps lock is on and a key is pressed, hyper driver is turned on
var p = 0;//momentum
var v = 0;

var test = .5;


document.addEventListener('keydown', keyDown);
document.addEventListener('keyup', keyUp);
document.addEventListener("wheel", wheel);

function keyDown(){
	//console.log(event.keyCode);
	switch(event.keyCode) {
		case 87:
			w = true;
			break;
		case 65:
			a = true;
			break;
		case 83:
			s = true;
			break;
		case 68:
			d = true;
			break;
		case 81:
			q = true;
			break;
		case 69:
			e = true;
			break;
		case 32:
			p = 0;
			thrusters = 0;
			break;
		//default:
			//no default required for this
	}
}

function keyUp(){
	//console.log(event.keyCode);
	switch(event.keyCode) {
		case 87:
			w = false;
			break;
		case 65:
			a = false;
			break;
		case 83:
			s = false;
			break;
		case 68:
			d = false;
			break;
		case 81:
			q = false;
			break;
		case 69:
			e = false;
			break;
		//default:
			//no default required for this
	}
	if (event.getModifierState("CapsLock")) {
    	hyperdrive = true;
  	} else {
    	hyperdrive = false;
  	}
}
function wheel(){
	//console.log(event.deltaY);
	thrusters -= event.deltaY/100;//not sure why this has to be negative
}
//this is a web GL compatibility checked //didn't seem to work
//starting here
/*if ( WEBGL.isWebGLAvailable() ) {

	// Initiate function or other initializations here
	animate();

} else {

	const warning = WEBGL.getWebGLErrorMessage();
	document.getElementById( 'container' ).appendChild( warning );

}*/
//ending here
	
//first tutorial (a cube spinning)
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000);			

const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight); 
document.body.appendChild( renderer.domElement );//document.getElementById("body").appendChild( renderer.domElement );

// now everything is set up, so the coding cube can be placed

//everything in the universe's reference frame should be added to this group
var universe = new THREE.Group()
//var universe = new THREE.Object3D()


//green cube
const geometry = new THREE.BoxGeometry();
const material = new THREE.MeshBasicMaterial({color:0x00ff00});
const cube = new THREE.Mesh(geometry, material);

universe.add(cube);

//green cube 2
const geometry3 = new THREE.BoxGeometry(1,1,80);
const cube2 = new THREE.Mesh(geometry3, material);
cube2.position.y = 20;

universe.add(cube2)


//create a blue LineBasicMaterial
const blueMaterial = new THREE.LineBasicMaterial( { color: 0x0000ff } );

const points = [];
points.push( new THREE.Vector3( - 10, 0, 0 ) );
points.push( new THREE.Vector3( 0, 10, 0 ) );
points.push( new THREE.Vector3( 10, 0, 0 ) );

const geometry2 = new THREE.BufferGeometry().setFromPoints( points );
const line = new THREE.Line( geometry2, material );

universe.add(line);



scene.add( universe );

camera.position.z = 100;
camera.lookAt(0,0,0);



universe.matrix.matrixAutoUpdate = false;
function animate() {
	cube.rotation.x += 0.01;
	cube.rotation.y += 0.01;
	line.rotation.x += 0.02;

	//controls
	if(w){
		camera.rotation.x += .01;
	}
	if(a){
		camera.rotation.y += .01;
	}
	if(s){
		camera.rotation.x -= .01;
	}
	if(d){
		camera.rotation.y -= .01;
	}
	if(q){
		camera.rotation.z += .01;//not sure
	}
	if(e){
		camera.rotation.z -= .01;//not sure
	}
	camera.getWorldDirection(direction);
	var T = new THREE.Matrix4();
	//calculating velocity and the like
	p += thrusters/60;//momentum = F*time ... this is assuming 60 fps
	if (hyperdrive){
		if (p < 0){//NEGATIVE VALUES are squared, so rip
			v = -Math.sqrt((p/m)**2/(1+(p/m)**2/(c**2)));
		}
		else {
			v = Math.sqrt((p/m)**2/(1+(p/m)**2/(c**2)));
		}
		length_contraction = Math.sqrt(1-(v/c)**2)-test;
		
		//create the matrix
		
		var len1 = length_contraction-1;
		var u1 = direction.x;
		var u2 = direction.y;
		var u3 = direction.z;
		T.set(
		//universe.matrix.set(
			1+len1*u1*u1, 0+len1*u2*u1, 0+len1*u3*u1, 0,
			0+len1*u1*u2, 1+len1*u2*u2, 0+len1*u3*u2, 0,
			0+len1*u1*u3, 0+len1*u2*u3, 1+len1*u3*u3, 0,
			0,            0,            0,            1
		);
		//universe.matrix.updateMatrix();
		/*I = [1+len1*u1*u1, 0+len1*u2*u1, 0+len1*u3*u1, 0,
			0+len1*u1*u2, 1+len1*u2*u2, 0+len1*u3*u2, 0,
			0+len1*u1*u3, 0+len1*u2*u3, 1+len1*u3*u3, 0,
			0,            0,            0,            1];*/
		//for i in range(0,16):
		//	universe.matrix.elements[i] = I[i];
		//universe.matrix.elements(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);
		//universe.matrix.matrixAutoUpdate = false;
		//T.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1); //I4
		//var temp_pos = new THREE.Vector3();
		//var temp_q = new THREE.Quaternion();
		//var temp_scale = new THREE.Vector3();
		//T.decompose(temp_pos, temp_q, temp_scale);
		
		//universe.position = temp_pos;
		//universe.quaternion = temp_q;
		//universe.scale = temp_scale;
		
		//universe.matrix.elements = (T);
		universe.applyMatrix4(T);//scale.set(direction.x*1,direction.y*1,direction.z*1);
		
		//universe.matrix.identity();//set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);
		//console.log(T);
		//console.log(universe.matrix.elements);
	}
	else {
		v = p/m; // v*m = p
	}
	camera.position.addScaledVector(direction, v);//I need to change everything, but for the time being, this is good.
	//length_contraction = Math.sqrt(1-(thrusters/c)**2);
	//console.log(Math.sqrt(direction.x**2+direction.y**2+direction.z**2));

	//console.log(universe.matrix.elements);
	/*if (universe.matrix.elements[10] == .5){
		alert("life1");
	}*/
	renderer.render(scene,camera);
	//console.log(universe.matrix.elements);
	/*if (universe.matrix.elements[10] == .5){
		alert("life2");
	}*/
	universe.position.set(0,0,0);
	universe.rotation.set(0,0,0);
	universe.scale.set(1,1,1);
	//universe.applyMatrix4(T.invert());//replace with something else
	requestAnimationFrame(animate);
}
animate();
// interesting space pirates game idea:  kinda like the sea pirates game, but where you upgrade your ship.  
// in it, you have up to 4 people all working together to pilate a space craft, this means: stir the ship, fire the cannons, man the shields, and repair any damages.  if there is pvp, the ships is insured, however pve, ship is not fully ensured.






		</script>
	</body>
</html>